<!--
vim: tw=80 cc=81

SPDX-FileCopyrightText: 2025 Eli Array Minkoff

SPDX-License-Identifier: 0BSD
-->

# 2021 Day 24

Well this is a doozy.

My first thought was that I could convert the code into C and rely on a powerful
C compiler's optimizer. I double-checked, and C division for C99 and above is
explicitly defined to truncate towards zero. I suspected that the operation was
designed so that it would take too long even with optimization, but decided to
try anyway.

The following starts out as a simplified version of my thought process, ironing
out some of the jumps around and presenting it as more linear than it actually
was. After a 3-month break, and using this document as a journal of my approach,
and a place to write my thoughts out as I worked on it, in order to help make
sense of things. As a result it became more and more scatterbrained, and I
didn't want to spend that much time on cleaning things up.

## First approach - convert to C and trust the optimizer

I used the following AWK script to convert the input into `monad.c`:

```awk
#!/usr/bin/env -S awk -f

# SPDX-FileCopyrightText: 2025 Eli Array Minkoff
#
# SPDX-License-Identifier: 0BSD

# Solution to AoC 2021 Day 24 Part 1
BEGIN {
    print "#include <stdbool.h>"
    print
    print "bool monad(char digits[const 14]) {"
    print "    int i = 0;"
    print "    long w = 0, x = 0, y = 0, z = 0;"
}
$1 == "inp" { print "    " $2 " = digits[i++];"; next }
$1 == "add" { print "    " $2 " += " $3 ";"; next }
$1 == "mul" { print "    " $2 " *= " $3 ";"; next }
$1 == "div" { print "    " $2 " /= " $3 ";"; next }
$1 == "mod" { print "    " $2 " %= " $3 ";"; next }
$1 == "eql" { print "    " $2 " = " $2 " == " $3 ";"; next }

# all valid lines should already have been handled.
{ print "invalid line: \"" $0 "\""; exit 1 }

END {
    print "    return z == 0;"
    print "}"
}
```

The idea is that I would use that function, and start with a loop that goes
through all sequences of digits in descending order.

I need to make sure that the value fits within the variable type, so I pulled up
a Python REPL:

```python
int('9' * 14).bit_length()
```

It resolved to `47`, so a type of at least 47 bits is needed. The C standard
requires that `long` is at least 32 bits, so it may or may not be long enough. I
know that glibc disagres with MSVC about whether it's 64 or 32 bits, but always
need to double check which is which. Let's go with `long long` to avoid that
mess - it's always at least 64 bits.

I pictured something with the following structure:

```c
#include <stdlib.h>
#include <stdio.h>

// in source file generated with to_c.awk
bool monad(char digits[const 14]);

static long long highest_valid() {
    char digits[14] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
    while (true) {
        if (monad(digits)) {
            // convert digits to long long and return it;
        }
        // Decrement least significant digit, and if it's zero, reset it to 9
        // and go to the next digit. If most significant digit would go to 0,
        // error out.
    }
}

int main() {
    long long highest = highest_valid();
    printf("%lld\n", highest);
    return 0;
}
```

For decrementing, I envisioned something that would iterate backwards through
the digits, setting them to the appropriate values, and wrote the following
function and set them:

```c
static bool decrement(char digits[14]) {
    for (int i = 13, i > -1; --i) {
        if (--(digits[i])) { return true; }
        digits[i] = 9;
    }
    return false;
}
```

*(In retrospect, `i >= 0` would've been a clearer way to write the condition.)*

Using that in the `highest_valid` function in the `while` loop simplifies
the structure, though a `while (decrement(digits))` loop would skip the highest
value. In retrospect, I should've used a `do ... while` loop, but it didn't
occur to me, so I just set the last digit to `10`, an ugly hack.


```c
#include <stdio.h>
#include <stdlib.h>

// in source file generated with to_c.awk
bool monad(char digits[const 14]);

static bool decrement(char digits[14]) {
    for (int i = 13; i > 5; --i) {
        if (--(digits[i])) { return true; }
        digits[i] = 9;
    }
    return false;
}

static long long highest_valid() {
    char digits[14] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10};
    while (decrement(digits)) {
        if (monad(digits)) {
            // return digits converted into a long long.
        }
    }
    fputs("No valid value found\n", stderr);
    exit(EXIT_FAILURE);
}

int main() {
    long long highest = highest_valid();
    printf("%lld\n", highest);
    return 0;
}
```

I decided to just use `strtoll` to convert to a number, instead of a
custom-built function, which required a bit of boilerplate:

```c
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

// in source file generated with to_c.awk
bool monad(char digits[const 14]);

static bool decrement(char digits[14]) {
    for (int i = 13; i > -1; --i) {
        if (--(digits[i])) { return true; }
        digits[i] = 9;
    }
    return false;
}

static long long highest_valid() {
    // least significant digit starts at 10 to avoid skipping the highest value.
    // Add a null terminator because it's passed to `strtoll`.
    char digits[15] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 0};
    while (decrement(digits)) { 
        if (monad(digits)) {
            // need to reset to check strtoll for errors
            errno = 0;
            char *p = digits;
            // convert from the numeric values to the digit character
            while (*p) {
                *p += '0';
                ++p;
            }
            long long ret = strtoll(digits, NULL, 10);
            if (errno) {
                perror("strtoll");
                exit(EXIT_FAILURE);
            }
            return ret;
        }
    } 
    fputs("No valid value found\n", stderr);
    exit(EXIT_FAILURE);
}

int main() {
    long long highest = highest_valid();
    printf("%lld\n", highest);
    return 0;
}
```

To compile `monad.c`, I ran the following:
```sh
gcc -O3 -c -std=c23 monad.c
```

To compile the "driver" file, I ran the following:

```sh
gcc -O3 -std=c23 -o part1 monad.o part1_2021_24.c
```

As I feared, it was taking a while, so I added a bit of logic to print each
number to `stderr` before checking it, to make sure that it's working. Because
`stderr` is unbuffered by default, I decided to print it a line at a time, and
because that could add to the time needed, I decided to put the debug printer in
a conditionally-compiled block:

```c
static long long highest_valid() {
    // least significant digit starts at 10 to avoid skipping the highest value.
    // Add a null terminator because it's passed to `strtoll`.
    char digits[15] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 0};
    while (decrement(digits)) { 
#ifndef NDEBUG
        char dbg_digits[16] = {[14] = '\n', [15] = 0};
        for (int i = 0; i < 14; ++i) dbg_digits[i] = digits[i] + '0';
        fputs(dbg_digits, stderr);
#endif
        if (monad(digits)) {
            ...
        }
    } 
    fputs("No valid value found\n", stderr);
    exit(EXIT_FAILURE);
}
```

It was clearly working, but taking a while, so I modified `decrement` to only
decrement around 1/3 of the digits, and calculated the time needed for the full
thing in a Python repl, and got a rough estimate that at the rate it was going,
it would take 333 days to get through all possible values with debug printing,
and over a day without. Switching to `clang` unsurprisingly didn't seem to make
a huge difference, so it was time for a different approach.

## Second approach - Create a tailor-made optimizer

I'd been getting a bit bored hacking at my optimizing brainfuck compilers, and
wanted to compile a more properly-structured language, to learn about compiler
design, so this may be shaped by my toying with those thoughts.

Because each assignment overwrites the previous value of the register, I had the
idea of treating each version of `w`, `x`, `y`, and `z` as its own variable, to
simplify the process of analyzing and optimizing the calculation.

I spent a while trying to model the data and its various states in Rust, but did
not get very far. While doing that, I did notice that the input code often
multiplied variables by 0, which would reset them, and seemed to follow a
certain structure, so I decided to move on to looking at that.

## Third approach - Mostly manual analysis leading to program design

I started to manually go through the program, step by step, keeping track of
what would be in each register, using the notation D0-D13 for the inputs.
*(`D` stands for "digit" here.)*

I'd have annotated 2nd example program as follows:

```
inp z   | 0 | 0  | 0 | D0           | (Brief notes or comments may go here)
inp x   | 0 | D1 | 0 | D0           |
mul z 3 | 0 | D1 | 0 | D0 * 3       |
eql z x | 0 | D1 | 0 | D1 == D0 * 3 |
```

This was tedious, but was intended to get a sense of how the program worked,
rather than get the full answer.

After reaching the 3rd `inp` instruction, I saw that the program seemed to have
the same series of instructions after each `inp` instruction, so I moved each
instruction that wasn't an `inp` instruction into the same line as the `inp`
instruction, separated by tabs. I saw that each line had 18 instructions, and
almost all of the instructions were the same in each column. *(This required
setting tab width to at least 10 to keep things aligned)*.

Saving the restructured input to `patterns`, I then opened up another Python
repl, and ran the following:

```python
with open("patterns") as f:
    lines = f.readlines()

groups = [line.strip().split("\t") for line in lines]
for i in range(18):
    if len(set(group[i] for group in groups)) != 1:
        print(i)
```

That printed out `4`, `5`, and `15`, so I knew where the difference between the
blocks was.

I then ran the following to see what different values were used for each one:

```python
set(group[4] for group in groups)
set(group[5] for group in groups)
set(group[15] for group in groups)
```

The instruction at index 4 was always one of `div z 1` or `div z 26`.

The instruction at index 5 was an `add x` instruction, where the value to add
was one of 11 different literal values, the lowest being `-13`, and the highest
being `15`.

The instruction at index 15 was an `add y` instruction, adding one of 10
different literal valuess, the lowest being `1`, and the highest, once again,
being `15`.

Replacing the varying values with symbols `P0` through `P2`, each block had the
following structure:

```
inp w
mul x 0
add x z
mod x 26
div z P0
add x P1
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y P2
mul y x
add z y
```

Using an extended version of the symbolic annotation I'd used above, with `Dn`
for "*n*ext digit", and `Vw` through `Vz` for initial values of the variables,
and new symbols added between instructions using the syntax
`>>> NAME := definition` to avoid too much noise, each block does the following:

```

inp w     | Dn | Vx             | Vy | Vz      |
mul x 0   | Dn | 0              | Vy | Vz      |
add x z   | Dn | Vz             | Vy | Vz      |
mod x 26  | Dn | Vz % 26        | Vy | Vz      |
div z P0  | Dn | Vz % 26        | Vy | Vz / P0 |
add x P1  | Dn | (Vz % 26) + P1 | Vy | Vz / P0 |

>>> EQ := Dn == (Vz % 26) + P1

eql x w   | Dn | EQ  | Vy          | Vz / P0 |
eql x 0   | Dn | !EQ | Vy          | Vz / P0 |
mul y 0   | Dn | !EQ | 0           | Vz / P0 |
add y 25  | Dn | !EQ | 25          | Vz / P0 |
mul y x   | Dn | !EQ | EQ ? 0 : 25 | Vz / P0 |

>>> TERN := EQ ? 1 : 26

add y 1   | Dn | !EQ | TERN | Vz / P0 |

>>> PROD := (Vz / P0) * TERN

mul z y   | Dn | !EQ | TERN    | PROD                                   |
mul y 0   | Dn | !EQ | 0       | PROD                                   |
add y w   | Dn | !EQ | Dn      | PROD                                   |
add y P2  | Dn | !EQ | Dn + P2 | PROD                                   |
mul y x   | Dn | !EQ | EQ ? 0 : (Dn + P2) | PROD                        |
add z y   | Dn | !EQ | EQ ? 0 : (Dn + P2) | PROD + (EQ ? 0 : (Dn + P2)) |
```

Resolving the symbols, the values in each variable at the end of the block are
as follows:

| var | value                                                                |
|-----|----------------------------------------------------------------------|
| `w` | `Dn`                                                                 |
| `x` | `Dn != ((Vz % 26)) + P1`                                             |
| `y` | `(Dn == ((Vz % 26) + P1)) ? 0 : (Dn + P2)`                           |
| `z` | `((Vz/P0)*((Dn==((Vz%26)+P1))?1:26))+((Dn==((Vz%26)+P1))?0:(Dn+P2))` |


While ~~a mess that ruined my efforts to keep this file within 80 columns until
I removed the whitespace~~ not particularly readable, one thing that's
noteworthy is that the only starting variable value that matters in the end is
`z` - the others are overwritten before reaching it.

Let's rewrite `z` in a more readable form - first, pipe it through
`clang-format`, as it uses C-compatible notation

```c
((Vz / P0) * ((Dn == ((Vz % 26) + P1)) ? 1 : 26)) +
    ((Dn == ((Vz % 26) + P1)) ? 0 : (Dn + P2))
```

Then, rewrite the ternaries into the less concise, but clearer form of Rust if 
expressions

```rust
(
  ((Vz / P0) * (if Dn == ((Vz % 26) + P1) { 1 } else { 26 })) +
     (if Dn == ((Vz % 26) + P1) { 0 } else { Dn + P2 })
```

Now, it can be rewritten as a Rust function, which takes the previous value of
`z` and the digit as input:


```rust
fn block<const P0: i64, const P1: i64, const P2: i64>(
    d: NonZeroDigit,
    z: i64,
) -> i64 {
    let d = d as i64;
    ((z / P0) * (if d == ((z % 26) + P1) { 1 } else { 26 }))
        + if d == ((z % 26) + P1) { 0 } else { d + P2 }
}
```
*(For purposes of this writeup, assume `NonZeroDigit` is an enum which can be
converted to `i64` with the `as` operator.)*

Next, split it into multiple steps:

```rust
fn block<const P0: i64, const P1: i64, const P2: i64>(
    d: NonZeroDigit,
    z: i64,
) -> i64 {
    let d = d as i64;
    let a = (z / P0) * (if d == (z % 26) + P1 { 1 } else { 26 });
    let b = if d == (z % 26) + P1 { 0 } else { d + P2 };
    a + b
}
```

There are 2 conditional expressions, and they share a condition, so they can be
combined:

```rust
fn block<const P0: i64, const P1: i64, const P2: i64>(
    d: NonZeroDigit,
    z: i64,
) -> i64 {
    let d = d as i64;
    let mut ret = z / P0;
    if d == (z % 26) + P1 {
        ret *= 1;
        ret += 0;
    } else {
        ret *= 26;
        ret += d + P2;
    }
    ret
}
```

Let's remove the needless mutability:

```rust
fn block<const P0: i64, const P1: i64, const P2: i64>(
    d: NonZeroDigit,
    z: i64,
) -> i64 {
    let d = d as i64;
    let n = z / P0;
    if d == (z % 26) + P1 {
        n
    } else {
        n * 26 + d + P2
    }
}
```

The problem is that this uses const generics, which must be known at compile
time, and thus can't be filled in using the input.

The solution is to instead create a struct with an `into_fn` method:

```rust
#[derive(Debug, Clone, Copy)]
struct DigitBlock(i64, i64, i64);

impl DigitBlock {
    fn into_fn(self) -> impl Fn(NonZeroDigit, i64) -> i64 {
        let DigitBlock(p0, p1, p2) = self;
        move |d: NonZeroDigit, z: i64| {
            let d = d as i64;
            let n = z / p0;
            if d == (z % 26) + p1 {
                n
            } else {
                n * 26 + d + p2
            }

        }
    }
}
```

Now, before anything else, I want to make sure that my model of each block is
accurate - first, let's modify the `to_c.awk` script for easier use with Rust:
```awk
#!/usr/bin/env -S awk -f
BEGIN {
    print "#include <stdint.h>"
    print "int64_t monad(char digits[const 14]) {"
    print "    int i = 0;"
    print "    int64_t w = 0, x = 0, y = 0, z = 0;"
}
$1 == "inp" { print "    " $2 " = digits[i++];"; next }
$1 == "add" { print "    " $2 " += " $3 ";"; next }
$1 == "mul" { print "    " $2 " *= " $3 ";"; next }
$1 == "div" { print "    " $2 " /= " $3 ";"; next }
$1 == "mod" { print "    " $2 " %= " $3 ";"; next }
$1 == "eql" { print "    " $2 " = " $2 " == " $3 ";"; next }

# all valid lines should already have been handled.
{ print "invalid line: \"" $0 "\""; exit 1 }

END {
    print "    return z;"
    print "}"
}
```

The differences are that it returns the value of `z` at the end, rather than a
boolean value, and it returns a fixed size `int64_t` for easier use with Rust's
types.

I then created the source file `validate.rs` that's in the `part1_assets`
folder, which I used to validate that my model of each block was correct, and it
was.

For the next step, I decided to try to work through it backwards - for each of
the possible input digits, what properties must a starting value of `z` have to
end with `z=0`?

While I don't want to include all of my input, I will fill in the blanks for
this.

```rust
fn last_block(d: NonZeroDigit, z: i64) -> i64 {
    let d = d as i64;
    let n = z / 26;
    if d == (z % 26) + -13 {
        n
    } else {
        n * 26 + d + 6
    }
}
```


### Back After Months

I then got caught up with other things, and took nearly 3 months to get back to
this. I'm glad I documented my approach, as it made it possible to see where I'd
left off.

A few hours of mulling it over on-or-off while working on other things, the
approach I have in mind is to solve for zero for the final digit, and find what
starting `z` values fit.

#### Last Block

So there's 2 branches that the input can take:

If `(z % 26) - 13 == d`, then it returns `z / 26`. For that to truncate to zero,
`z` must be equal to `13 + d`.

If `(z % 26) - 13 != d`, then it returns `(z / 26) * 26 + d + 6`. Due to
truncation towards zero, `(z / 26) * 26` does not simplify, but it is equal to
`z - (z % 26)`

`sympy` resolves `Eq(26 * floor(z/26) + 1 + 6, 0)` to `False`, meaning that
there's no previous value for `z` which is accepted for `d = 1`.

Taking my work in a REPL with `sympy`, and minifying it:

```python
from sympy import *
z = symbols('z', integer=true)
can_resolve = {}
for d in range(1, 10):
    sol = Eq(floor(z / 26) * 26 + d + 6, 0)
    print(f"{d}: {sol}")
```

Output:

```
1: False
2: Eq(26*floor(z/26) + 8, 0)
3: False
4: Eq(26*floor(z/26) + 10, 0)
5: False
6: Eq(26*floor(z/26) + 12, 0)
7: False
8: Eq(26*floor(z/26) + 14, 0)
9: False
```

So the second branch won't accept odd digits at all. What I noticed after
thinking a bit is that there's no possible integer value for `z` such that
`(z/26)*26` will equal any of the values `8`, `10`, `12`, or `14`, so the second
branch can't actually return `0`.

Based on that, the starting value for `z` when the last block is hit must be
`13+d`, where `d` is the final digit. As `d` must be a nonzero digit, `13+d`
must be on the interval `[14,22]`. (Just thinking in terms of closed intervals
has me thinking back to high school math.)

Now, onto the second-to-last block:

```rust
blocks[12] = |d: NonZeroDigit, z: i64| -> i64 {
    if (z % 26) - 2 == d as i64 {
        z / 26
    } else {
        (z / 26) * 26 + (d as i64) + 13
    }
};
```

So the question is what inputs could result in a returned value on the interval
`[14,22]`.

```rust
if (z % 26) - 2 == d {
    z / 26
} else {
    z / 26 * 26 + d + 13
}
```

Let's look at the second branch first. If `z >= 26` or `z<=-26`, then it will
make it impossible for the second branch to return a number in range.

I used the following in a Python REPL to find all integers on the interval
`[-25,25]` which, for a given digit, would take the second branch, and result in
a number in range.

The following prints all possible `d,z` pairs that result in a number in the
interval from the second branch:
```python
for d in range(1, 10):
    for z in range(-25, 25):
        if z % 26 != d:
            if (nz := (z // 26 * 26 + d + 13)) in range(14, 23):
                print(f"{d}, {z}: {nz}, {nz - 13}")
```

The following prints all `d, z` combinations on the interval that take the first
branch:

```python
for d in range(1, 10):
    for z in range(-25, 25):
        if z % 26 == d:
            print(f"{d}: {z}")
```

The following prints all `d, z` combinations on the interval that take the first
branch, and result in a number in range. Given that it produces no output, no
such combinations exist.

```python
for d in range(1, 10):
    for z in range(-25, 25):
        if (nz := (z // 26) in range(14, 23):
            print(f"{d}: {z}, {nz}, {nz - 13}")
```

What I found was that any number in the `[0,25]` would work for any digit, as
long as `d` was the same as the final digit, and `z` was not equal to `d+2`.

For the first branch, `z/26` would need to evaluate to a number in range, and
`z` would need to be equivalent to `d + 2` mod `26`.

So for branch 1 to work out, `z` needs to be `26 * Nz + d`, where `Nz` is the
next value of `z`, which is in turn 13 more than the final digit.

In the following table, each column represents the 2nd-to-last digit, and the
row represents the last digit. Each cell shows the value that would need to
be used for that combination to work.

|   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
|---|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| 1 | 353 | 354 | 355 | 356 | 357 | 358 | 359 | 360 | 361 |
| 2 | 379 | 380 | 381 | 382 | 383 | 384 | 385 | 386 | 387 |
| 3 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 |
| 4 | 431 | 432 | 433 | 434 | 435 | 436 | 437 | 438 | 439 |
| 5 | 457 | 458 | 459 | 460 | 461 | 462 | 463 | 464 | 465 |
| 6 | 483 | 484 | 485 | 486 | 487 | 488 | 489 | 490 | 491 |
| 7 | 509 | 510 | 511 | 512 | 513 | 514 | 515 | 516 | 517 |
| 8 | 535 | 536 | 537 | 538 | 539 | 540 | 541 | 542 | 543 |
| 9 | 561 | 562 | 563 | 564 | 565 | 566 | 567 | 568 | 569 |

Looking over the list of all blocks, I see that there's a relationship between
the first 2 fields in the `DigitBlock` struct: if the first one is `1`, then the
second field is positive, and if it's `26`, the second is negative.

#### Detour

Before continuing down that path, I decided to see if I could find a correlation
between the input and output, so I wrote up a simple `monad.h` and `main.c`:

##### `monad.h`

```cpp
#ifndef MONAD
#define MONAD
#include <stdint.h>
int64_t monad(char digits[const 14]);
#endif
```

##### `main.c`

```c
#include <inttypes.h>
#include <stdio.h>

#include "monad.h"
int64_t monad(char digits[const 14]);

static bool decrement(char digits[14]) {
    for (int i = 13; i > -1; --i) {
        if (--(digits[i])) { return true; }
        digits[i] = 9;
    }
    return false;
}

static char *pri(char digits[const 14]) {
    static char BUF[15] = {};
    for (int i = 0; i < 14; ++i) BUF[i] = digits[i] + '0';
    return BUF;
}

int main() {
    char digits[14] = {9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
    do {
        printf("%s â‡’ %" PRIi64 "\n", pri(digits), monad(digits));
    } while (decrement(digits));
}
```

I compiled with the `clang-21` build provided by the LLVM repo for Debian, then
decided to run it for 30 seconds and see if I could find a pattern:

```bash
clang-21 -Wall -Wextra -O3 -g3 main.c monad.c -std=c23 -flto -o tst
timeout 30 ./tst >out
```

On my current system, the resulting output was around 12 GiB in size, with over
400 million lines of output, so I decided to cut it down to the first 10,000.
I decided to truncate it to 10,000 lines. Even then, the only pattern I saw was
that it seemed to loop through the same series of 10 numbers, interrupted
somewhat unpredictably by a lower number that only changed once within the first
10000 lines. Not super helpful.

It did seem to be running pretty fast, even with output, so I decided to retry
letting it run for a while, and redo the math around how long it would take that
I'd done a few months back, with slightly worse results, likely because I had
other things running concurrently, and I think I recall logging in to a TTY to
get the time estimates last time. It would take around 2.3 days to run through
all possible inputs at the rate it was, though if the highest possible input
is the target, it may finish within a matter of hours, not days. Still not
ideal.

I made some changes allow providing an alternate starting point, instead of all
`9`s, then turned the digits array into a static variable at the file scope,
enabling a signal handler for SIGUSR1 to print the current progress to stderr.
Due to issues mixing stdlib I/O and I/O using file descriptors, and the fact
that the stdlib I/O functions are not signal safe but POSIX `write` is, I
switched to raw POSIX `writes` for all I/O except for the `perror` call, which
is only called if the code takes a path that avoids all other I/O, and
immediately exits.

I ran that off-and-on for a while, though regrettably didn't time it. I kept
that running in the background for the majority of the time I was trying to
figure things out.

I then decided to see if parsing the input smaller C functions in a way that's
aware of the structure of the input as I understand it so far, and found that
there's a noticeable speedup, but not enough to be usable. While using that
approach, however, I decided to make the individual functions available in a
shared object file, and I created a Python module that would provide a `BLOCKS`
list with the 14 callable functions. I compiled `custom_runnable` to test it,
with a hacky `-Dmonad=custom_monad` flag to call the `custom_monad` function
that was generated with understanding of the structure, rather than the `monad`
that was a direct translation of the input. I had `custom_runnable` take over
the background brute-force work.

I then spent several hours trying to create a memoization system in C, and it
was even slower, so I installed `linux-perf` to figure out why. The memoization
system was branching far more, and was hitting mispredicted branches far more,
leading to it running far slower in general. I'm not sure if the cache was too
small, or if my effort to implement it was messy.

#### Detour Over

After that mostly-fruitless detour, I decided to get a better understanding of
the individual blocks.

So the number 26 keeps coming up - maybe it has to do with the alphabet?

In a Python REPL, I used the following to experiment a bit

```python
from custom_monad import BLOCKS
from string import ascii_lowercase

def to_alpha(digits):
    value = int("".join(str(d) for d in digits))
    s = ""
    while value:
        s = f"{ascii_lowercase[value % 26]}{s}"
        value //= 26
    return s

def from_alpha(s):
    assert s.isascii() and s.islower()
    value = 0
    for c in s:
        value *= 26
        value += ascii_lowercase.index(c)
    return str(value)
```

Right as I thought I was onto something, the brute-force approach I'd been
running in the background for the majority of the past 24 hours spit out an
answer.

That was accepted as the correct answer, but before even looking at part 2, I
wanted to get some understanding as to why. With the REPL still up, I decided to
see what the fruits of my work had to say about the answer I got:

```python
>>> to_alpha(9$REDACTED$91)
'r$REDACTED$h'
>>> [ord(c) - ord('a') for c in to_alpha(9$REDACTED$91)]
[17, 22, 2, 23, 5, 23, 20, 14, 8, 7]
>>> BLOCKS[0](9, 0)
14
```

That seemed to be less than immediately helpful information.

Let's look at the last 2 digits in the context of the breakdown above:

So for the last digit to be 1, the second-to-last value of z would need to have
been 14.

Looking back at the structure of the second-to-last block, I suddenly recognized
the general pattern of it, from my algorithm for printing the ASCII decimal
representation of a number in more minimal languages that don't have a function
for that. I don't know if that's a real connection, or a sign that the insanity
is truly starting to creep in.

Redoing the functions, using the alphanumeric sequence
`"0123456789abcdefghijklmnopq"` instead of the alphabet, I found that the tools
were similarly unhelpful - until I noticed something:

The last digit block's parameters (i.e. `(26, -13, 6)`), added to the last
base-26 digit (`7`), results in 26. I have no idea whether or not that matters.

Let's look at the 1st block - I've looked closely at blocks with `P0=26, P1<0`,
but never `P0=1, P1>0`, even though I noticed that all blocks were one of those
two.

```rust
blocks[0] = |d: NonZeroDigit, z: i64| -> i64 {
    if (z % 26) + 11 == d as i64 {
        z / 1
    } else {
        (z / 1) * 26 + (d as i64) + 5
    }
};
```

So putting aside the knowledge that that has known input at the start, the
following can be determined:

The top condition is `false` - the highest value of `d` is 9, and the modulo
will ensure `z` is non-negative. It can be simplified to the following:

```rust
blocks[0] = |d: NonZeroDigit, z: i64| { z * 26 + (d as i64) + 5 };
```

Looking over all of the blocks with `P0=1`, the same analysis is true for all of
them.

Looking at all of the `P0=26` blocks, none of them are forced into the second
path universally like that.

So for all of the `P0=1` blocks, the second parameter can be ignored.

The next thing I noticed was that there were the same number of `P0=1` and
`P0=26` blocks - 7 each. Maybe ending on `0` would require it to always take the
upper path on `P0=26` blocks, as otherwise it winds up staying just as far away
from `0`? That's a thought.

Anyway, so let's look at the answer I got with that in mind.

```rust
blocks[13] = |d: NonZeroDigit, z: i64| -> i64 {
    if (z % 26) - 13 == d as i64 {
        z / 26
    } else {
        (z / 26) * 26 + (d as i64) + 6
    }
};
```

The last digit is 1, and `z` is set to 13.

So filling it in:

```rust
    if (14 % 26) - 13 == 1 {
        14 / 26
    } else {
        (14 / 26) * 26 + 7
    }
```

For it to go to zero, it needed to hit the first branch. It seems almost like
it's pushing base-26 digits onto or off of a stack.

#### So It's a Stack.

*It's at this point that I should probably disclose that I did see people claim
that the code was somehow simulating a stack of some kind, involving a base-26
numbering system, but I didn't quite understand how, so I tried not to use that
knowledge to guide my understanding, unless I could find a way to plausibly have
come to that conclusion on my own. It would be dishonest not to disclose that,
but for the sake of my own learning, I wanted to try to figure it out myself.*

If I view it as a stack, then the `P0=1` operations push the sum of the digit
and their `P2` parameter to the stack, but I still don't fully get what the
`P0=26` operations are doing, due to the division.

So `z % 26` can be thought of as the top of the stack. So with that in mind, the
final block can be thought of as follows:

```rust
blocks[13] = |digit, stack| { 
    if stack.top() == (digit as i64) + 13 {
        stack.pop();
    } else {
        stack.pop();
        stack.push((digit as i64) + 5);
    }
    stack
};
```

I wrote an AWK script to process the input into a stack-based pseudocode:

```awk
#!/usr/bin/env -S awk -f
## SPDX-FileCopyrightText: 2025 Eli Array Minkoff
#
# SPDX-License-Identifier: 0BSD

BEGIN { block = 0 }
# don't increment the starting block 
/inp/  && NR > 1{ ++block }
NR % 18 == 5 { push_pop = ($3 != 1) }
NR % 18 == 6 {
    if(push_pop) printf "if (POP() - %d != digits[%d]) ", -$3, block
}
NR % 18 == 16 {
    print "PUSH(digits[" block "] + "$3")"
    print ""
}
```

It became clear that it's a encoding series of relationships that must hold
between the digits. I went back and redacted the answer I found earlier in this
writeup, to avoid revealing reveal more of my input than needed.

With that in mind, I was finally able to create a "proper" solution.
